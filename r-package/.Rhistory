#base atual
url_a <- "ftp://geoftp.ibge.gov.br/organizacao_do_territorio/estrutura_territorial/localidades/Shapefile_SHP/"
years = getURL(url_h, ftp.use.epsv = FALSE, dirlistonly = TRUE)
years <- strsplit(years, "\r\n")
years = unlist(years)
years <- c(years, 2010)
#### 2. Create folders to save sf.rds files  -----------------
setwd(head_dir)
# create directory to save cleaned shape files in sf format
dir.create(file.path("shapes_in_sf_all_years_cleaned"), showWarnings = FALSE)
# create a subdirectory years
for (i in years){
dir.create(file.path("shapes_in_sf_all_years_cleaned", i), showWarnings = FALSE)
}
for (i in years){
# i=2010
dir_years <- paste0(head_dir,"//",i)
setwd(dir_years)
# selecionar apenas os arquivos .shp
dados <- list.files(pattern = "*.shp", full.names = T)
if (i!=2010){
# retirando os arquivos .xml da lista
dados <- dados[!grepl(".xml",dados)]
# mantendo apenas o arquivo de sede na lista
dados <- dados[grepl("sede",dados)]
}
# Lendo os shapes
setwd(paste0(head_dir,"//",i))
temp_sf <- st_read(dados, quiet = T, stringsAsFactors=F, options = "ENCODING=WINDOWS-1252")
# colocando o nome das colunas em letras minúsculas
names(temp_sf) <- names(temp_sf) %>% tolower()
# padroniza o nome da coluna para "code_muni"
if("codigo" %in% names(temp_sf)){
temp_sf <- dplyr::rename(temp_sf, code_muni = codigo)
} else if ("br91poly_i" %in% names(temp_sf)){
temp_sf <- dplyr::rename(temp_sf, code_muni = br91poly_i)
} else if ("geocodigo" %in% names(temp_sf)){
temp_sf <- dplyr::rename(temp_sf, code_muni = geocodigo)
} else {
temp_sf <- dplyr::rename(temp_sf, code_muni = cd_geocodm)
}
# arruma o name_muni
# seleciona apenas sede de municipios
#temp_sf <- subset(temp_sf, cd_nivel==1 )
# leitura dos municipios
municipios <- read_municipality(code_muni = 'all', year = i)
# seleciona apenas as colunas de name_muni e geometry
municipios <- municipios %>% select(-code_muni)
# harmoniza projecao
temp_sf <- st_transform(temp_sf, st_crs(municipios))
# faz intersecao
temp_sf <- st_join(temp_sf, municipios)
# seleciona apenas a sede
if(i==2010){# table(temp_sf$nm_categor, temp_sf$cd_nivel)
temp_sf <- subset(temp_sf, nm_categor == "CIDADE")
}
# organiza colunas
temp_sf <- dplyr::select(temp_sf, c('code_muni', 'name_muni', 'geometry'))
# cria a coluna ano
temp_sf$year <- i
### cria colunas de estado
# add State code
temp_sf$code_state <-  substr(temp_sf$code_muni,1,2)
# add State abbreviation
temp_sf <- temp_sf %>% mutate(abbrev_state =  ifelse(code_state== 11, "RO",
ifelse(code_state== 12, "AC",
ifelse(code_state== 13, "AM",
ifelse(code_state== 14, "RR",
ifelse(code_state== 15, "PA",
ifelse(code_state== 16, "AP",
ifelse(code_state== 17, "TO",
ifelse(code_state== 21, "MA",
ifelse(code_state== 22, "PI",
ifelse(code_state== 23, "CE",
ifelse(code_state== 24, "RN",
ifelse(code_state== 25, "PB",
ifelse(code_state== 26, "PE",
ifelse(code_state== 27, "AL",
ifelse(code_state== 28, "SE",
ifelse(code_state== 29, "BA",
ifelse(code_state== 31, "MG",
ifelse(code_state== 32, "ES",
ifelse(code_state== 33, "RJ",
ifelse(code_state== 35, "SP",
ifelse(code_state== 41, "PR",
ifelse(code_state== 42, "SC",
ifelse(code_state== 43, "RS",
ifelse(code_state== 50, "MS",
ifelse(code_state== 51, "MT",
ifelse(code_state== 52, "GO",
ifelse(code_state== 53, "DF",NA))))))))))))))))))))))))))))
# cria coluna de região
temp_sf$code_region <-  substr(temp_sf$code_muni,1,1)
### add region names
temp_sf$name_region <- ifelse(temp_sf$code_region==1, 'Norte',
ifelse(temp_sf$code_region==2, 'Nordeste',
ifelse(temp_sf$code_region==3, 'Sudeste',
ifelse(temp_sf$code_region==4, 'Sul',
ifelse(temp_sf$code_region==5, 'Centro Oeste', NA)))))
# organizando colunas
temp_sf <- dplyr::select(temp_sf, c('code_muni', 'name_muni', 'code_state', 'abbrev_state', 'code_region', 'name_region', 'year', 'geometry'))
# Use UTF-8 encoding
temp_sf$name_muni <- stringi::stri_encode(as.character(temp_sf$name_muni), "UTF-8")
# Harmonize spatial projection CRS, using SIRGAS 2000 epsg (SRID): 4674
temp_sf <- if( is.na(st_crs(temp_sf)) ){ st_set_crs(temp_sf, 4674) } else { st_transform(temp_sf, 4674) }
st_crs(temp_sf) <- 4674
# Convert columns from factors to characters
temp_sf %>% dplyr::mutate_if(is.factor, as.character) -> temp_sf
temp_sf$code_muni <- as.numeric(temp_sf$code_muni) # keep code as.numeric()
# Save cleaned sf in the cleaned directory
setwd(head_dir)
destdir <- file.path("./shapes_in_sf_all_years_cleaned",i)
sf::st_write(temp_sf, paste0(destdir,"/", "municipal_seat_",i, ".gpkg"))
}
View(temp_sf)
library(geobr)
# Get metadata with data addresses
metadata <- download_metadata()
# Select geo
temp_meta <- subset(metadata, geo=="amazonia_legal")
temp_meta
select_data_type <- function(temp_meta, tp){
# Select type
if(tp=="original"){
temp_meta <- temp_meta[  !(grepl(pattern="simplified", temp_meta$download_path)), ]
} else {
temp_meta <- temp_meta[  grepl(pattern="simplified", temp_meta$download_path), ]
}
}
select_data_type(temp_meta, tp)
tp="simplified"
select_data_type(temp_meta, tp)
a <- select_data_type(temp_meta, tp)
a
temp_meta
select_data_type(temp_meta, tp)
select_data_type <- function(temp_meta, tp){
# Select type
if(tp=="original"){
temp_meta <- temp_meta[  !(grepl(pattern="simplified", temp_meta$download_path)), ]
} else {
temp_meta <- temp_meta[  grepl(pattern="simplified", temp_meta$download_path), ]
}
return(temp_meta)
}
select_data_type(temp_meta, tp)
library(geobr)
a <- read_amazon(year=2012)
library(geobr)
2+2
library(geobr)
#'
b <- read_biomes(year=2019)
2+@
5+5
library(geobr)
ufs <- read_state(code_state="all", year=2010)
ufs <- read_state(code_state="all", year=1920)
# Get metadata with data addresses
metadata <- download_metadata()
# Select geo
temp_meta <- subset(metadata, geo=="state")
tp="simplified"
# Select geo
temp_meta <- subset(metadata, geo=="state")
# Select data type
temp_meta <- select_data_type(temp_meta, tp)
#' Select data type: 'original' or 'simplified' (default)
#'
#'
select_data_type <- function(temp_meta, tp){
if(tp=="original"){
temp_meta <- temp_meta[  !(grepl(pattern="simplified", temp_meta$download_path)), ]
} else {
temp_meta <- temp_meta[  grepl(pattern="simplified", temp_meta$download_path), ]
}
return(temp_meta)
}
# Select data type
temp_meta <- select_data_type(temp_meta, tp)
year=1920
# Verify year input
if (is.null(year)){ message("Using data from year 2010\n")
year <- 2010
temp_meta <- subset(temp_meta, year==2010)
} else if (year %in% temp_meta$year){ temp_meta <- temp_meta[temp_meta[,2] == year, ]
} else { stop(paste0("Error: Invalid Value to argument 'year'. It must be one of the following: ",
paste(unique(temp_meta$year),collapse = " ")))
}
# BLOCK 2.1 From 1872 to 1991  ----------------------------
x <- year
if(is.null(code_state)){ stop("Value to argument 'code_state' cannot be NULL") }
message("Loading data for the whole country\n")
# list paths of files to download
filesD <- as.character(temp_meta$download_path)
filesD
# download files
temps <- paste0(tempdir(),"/", unlist(lapply(strsplit(filesD,"/"),tail,n=1L)))
httr::GET(url=filesD, httr::progress(), httr::write_disk(temps, overwrite = T))
# read sf
temp_sf <- sf::st_read(temps, quiet=T)
rm(temp_sf)
temps
temp_sf <- sf::st_read(temps, quiet=T)
plot(temp_sf)
# Get metadata with data addresses
metadata <- download_metadata()
year=2010
# Get metadata with data addresses
metadata <- download_metadata()
# Select geo
temp_meta <- subset(metadata, geo=="country")
temp_meta
# Select data type
temp_meta <- select_data_type(temp_meta, tp)
#' Select data type: 'original' or 'simplified' (default)
#'
#'
select_data_type <- function(temp_meta, tp){
if(tp=="original"){
temp_meta <- temp_meta[  !(grepl(pattern="simplified", temp_meta$download_path)), ]
} else {
temp_meta <- temp_meta[  grepl(pattern="simplified", temp_meta$download_path), ]
}
return(temp_meta)
}
# Select data type
temp_meta <- select_data_type(temp_meta, tp)
#' Select data type: 'original' or 'simplified' (default)
#'
#'
select_data_type <- function(temp_meta, tp){
if(tp=="original"){
temp_meta <- temp_meta[  !(grepl(pattern="simplified", temp_meta$download_path)), ]
} else {
temp_meta <- temp_meta[  grepl(pattern="simplified", temp_meta$download_path), ]
}
return(temp_meta)
}
#' Download geopackage to tempdir
#'
#'
download_gpkg <- function(){
temps <- paste0(tempdir(),"/", unlist(lapply(strsplit(filesD,"/"),tail,n=1L)))
httr::GET(url=filesD, httr::progress(), httr::write_disk(temps, overwrite = T))
}
# Select data type
temp_meta <- select_data_type(temp_meta, tp)
tp="simplified"
# Select data type
temp_meta <- select_data_type(temp_meta, tp)
# Verify year input
if (is.null(year)){ message("Using data from year 2010\n")
temp_meta <- subset(temp_meta, year==2010)
} else if (year %in% temp_meta$year){ temp_meta <- temp_meta[temp_meta[,2] == year, ]
} else { stop(paste0("Error: Invalid Value to argument 'year'. It must be one of the following: ",
paste(unique(temp_meta$year),collapse = " ")))
}
temp_meta
# list paths of files to download
filesD <- as.character(temp_meta$download_path)
temp_sf <- sf::st_read(temps, quiet=T)
download_gpkg()
temp_sf <- sf::st_read(temps, quiet=T)
#' Download geopackage to tempdir
#'
#'
download_gpkg <- function(){
temps <- paste0(tempdir(),"/", unlist(lapply(strsplit(filesD,"/"),tail,n=1L)))
httr::GET(url=filesD, httr::progress(), httr::write_disk(temps, overwrite = T))
return(temps)
}
temps <- download_gpkg()
# read sf
temp_sf <- sf::st_read(temps, quiet=T)
plot(temp_sf)
temps
read_state2 <- function(code_state="all", year=NULL, tp="simplified"){
# Get metadata with data addresses
metadata <- download_metadata()
# Select geo
temp_meta <- subset(metadata, geo=="state")
# Select data type
temp_meta <- select_data_type(temp_meta, tp)
# Verify year input
if (is.null(year)){ message("Using data from year 2010\n")
year <- 2010
temp_meta <- subset(temp_meta, year==2010)
} else if (year %in% temp_meta$year){ temp_meta <- temp_meta[temp_meta[,2] == year, ]
} else { stop(paste0("Error: Invalid Value to argument 'year'. It must be one of the following: ",
paste(unique(temp_meta$year),collapse = " ")))
}
# BLOCK 2.1 From 1872 to 1991  ----------------------------
x <- year
if( x < 1992){
#   if( !(substr(x = code_state, 1, 2) %in% temp_meta$code) &
#       !(substr(x = code_state, 1, 2) %in% temp_meta$code_abrev) &
#       !(substr(x = code_state, 1, 3) %in% "all")) {
#       stop("Error: Invalid Value to argument code_state.")
#       }
if(is.null(code_state)){ stop("Value to argument 'code_state' cannot be NULL") }
message("Loading data for the whole country\n")
# list paths of files to download
filesD <- as.character(temp_meta$download_path)
# download files
# temps <- paste0(tempdir(),"/", unlist(lapply(strsplit(filesD,"/"),tail,n=1L)))
# httr::GET(url=filesD, httr::progress(), httr::write_disk(temps, overwrite = T))
temps <- download_gpkg()
# read sf
temp_sf <- sf::st_read(temps, quiet=T)
return(temp_sf)
} else {
# BLOCK 2.2 From 2000 onwards  ----------------------------
# Verify code_state input
# if code_state=="all", read the entire country
if(code_state=="all"){ message("Loading data for the whole country\n")
# list paths of files to download
filesD <- as.character(temp_meta$download_path)
# input for progress bar
total <- length(filesD)
pb <- utils::txtProgressBar(min = 0, max = total, style = 3)
# download files
lapply(X=filesD, function(x){
i <- match(c(x),filesD)
httr::GET(url=x, #httr::progress(),
httr::write_disk(paste0(tempdir(),"/", unlist(lapply(strsplit(x,"/"),tail,n=1L))), overwrite = T))
utils::setTxtProgressBar(pb, i)
}
)
# closing progress bar
close(pb)
# read files and pile them up
files <- unlist(lapply(strsplit(filesD,"/"), tail, n = 1L))
files <- paste0(tempdir(),"/",files)
files <- lapply(X=files, FUN= sf::st_read, quiet=T)
shape <- do.call('rbind', files)
return(shape)
}
if( !(substr(x = code_state, 1, 2) %in% temp_meta$code) & !(substr(x = code_state, 1, 2) %in% temp_meta$code_abrev)){
stop("Error: Invalid Value to argument code_state.")
} else{
# list paths of files to download
if (is.numeric(code_state)){ filesD <- as.character(subset(temp_meta, code==substr(code_state, 1, 2))$download_path) }
if (is.character(code_state)){ filesD <- as.character(subset(temp_meta, code_abrev==substr(code_state, 1, 2))$download_path) }
# download files
temps <- paste0(tempdir(),"/", unlist(lapply(strsplit(filesD,"/"),tail,n=1L)))
httr::GET(url=filesD, httr::write_disk(temps, overwrite = T))
# read sf
shape <- sf::st_read(temps, quiet=T)
if(nchar(code_state)==2){
return(shape)
# } else if(code_state %in% shape$code_state){
#   x <- code_state
#   shape <- subset(shape, code_state==x)
#   return(shape)
} else{
stop("Error: Invalid Value to argument code_state.")
}
}
}}
read_state2 <- function(code_state="all", year=NULL, tp="simplified"){
# Get metadata with data addresses
metadata <- download_metadata()
# Select geo
temp_meta <- subset(metadata, geo=="state")
# Select data type
temp_meta <- select_data_type(temp_meta, tp)
# Verify year input
if (is.null(year)){ message("Using data from year 2010\n")
year <- 2010
temp_meta <- subset(temp_meta, year==2010)
} else if (year %in% temp_meta$year){ temp_meta <- temp_meta[temp_meta[,2] == year, ]
} else { stop(paste0("Error: Invalid Value to argument 'year'. It must be one of the following: ",
paste(unique(temp_meta$year),collapse = " ")))
}
# BLOCK 2.1 From 1872 to 1991  ----------------------------
x <- year
if( x < 1992){
#   if( !(substr(x = code_state, 1, 2) %in% temp_meta$code) &
#       !(substr(x = code_state, 1, 2) %in% temp_meta$code_abrev) &
#       !(substr(x = code_state, 1, 3) %in% "all")) {
#       stop("Error: Invalid Value to argument code_state.")
#       }
if(is.null(code_state)){ stop("Value to argument 'code_state' cannot be NULL") }
message("Loading data for the whole country\n")
# list paths of files to download
filesD <- as.character(temp_meta$download_path)
# download files
# temps <- paste0(tempdir(),"/", unlist(lapply(strsplit(filesD,"/"),tail,n=1L)))
# httr::GET(url=filesD, httr::progress(), httr::write_disk(temps, overwrite = T))
temps <- download_gpkg()
# read sf
temp_sf <- sf::st_read(temps, quiet=T)
return(temp_sf)
} else {
# BLOCK 2.2 From 2000 onwards  ----------------------------
# Verify code_state input
# if code_state=="all", read the entire country
if(code_state=="all"){ message("Loading data for the whole country\n")
# list paths of files to download
filesD <- as.character(temp_meta$download_path)
# input for progress bar
total <- length(filesD)
pb <- utils::txtProgressBar(min = 0, max = total, style = 3)
# download files
lapply(X=filesD, function(x){
i <- match(c(x),filesD)
httr::GET(url=x, #httr::progress(),
httr::write_disk(paste0(tempdir(),"/", unlist(lapply(strsplit(x,"/"),tail,n=1L))), overwrite = T))
utils::setTxtProgressBar(pb, i)
}
)
# closing progress bar
close(pb)
# read files and pile them up
files <- unlist(lapply(strsplit(filesD,"/"), tail, n = 1L))
files <- paste0(tempdir(),"/",files)
files <- lapply(X=files, FUN= sf::st_read, quiet=T)
shape <- do.call('rbind', files)
return(shape)
}
if( !(substr(x = code_state, 1, 2) %in% temp_meta$code) & !(substr(x = code_state, 1, 2) %in% temp_meta$code_abrev)){
stop("Error: Invalid Value to argument code_state.")
} else{
# list paths of files to download
if (is.numeric(code_state)){ filesD <- as.character(subset(temp_meta, code==substr(code_state, 1, 2))$download_path) }
if (is.character(code_state)){ filesD <- as.character(subset(temp_meta, code_abrev==substr(code_state, 1, 2))$download_path) }
# download files
# temps <- paste0(tempdir(),"/", unlist(lapply(strsplit(filesD,"/"),tail,n=1L)))
# httr::GET(url=filesD, httr::write_disk(temps, overwrite = T))
temps <- download_gpkg()
# read sf
shape <- sf::st_read(temps, quiet=T)
if(nchar(code_state)==2){
return(shape)
# } else if(code_state %in% shape$code_state){
#   x <- code_state
#   shape <- subset(shape, code_state==x)
#   return(shape)
} else{
stop("Error: Invalid Value to argument code_state.")
}
}
}}
ufs <- read_state(code_state="AL", year=2010)
plot(ufs)
uf <- read_state(code_state="SC", year=2000)
uf <- read_state(code_state=12, year=2017)
uf <- read_state(code_state=12, year=1991)
plot(uf)
ufs <- read_state(code_state="all", year=1872)
plot(ufs)
library(geobr)
# Load geobr and other libraries we'll use
library(geobr)
library(ggplot2)
library(sf)
library(dplyr)
library(rio)
# download data
state <- read_state(code_state="SE", year=2018)          # State
micro <- read_micro_region(code_micro=160101, year=2000) # Micro region
read_micro_region(code_micro=160101, year=2000)
code_micro=160101
year=2000
# Get metadata
metadata <- download_metadata()
# Select geo
temp_meta <- subset(metadata, geo=="micro_region")
tp="simplified"
# Select data type
temp_meta <- select_data_type(temp_meta, tp)
# Verify year input
if (is.null(year)){ message("Using data from year 2010\n")
temp_meta <- subset(temp_meta, year==2010)
} else if (year %in% temp_meta$year){ temp_meta <- temp_meta[temp_meta[,2] == year, ]
} else { stop(paste0("Error: Invalid Value to argument 'year'. It must be one of the following: ",
paste(unique(temp_meta$year),collapse = " ")))
}
# if code_micro=="all", read the entire country
if(code_micro=="all"){ message("Loading data for the whole country. This might take a few minutes.\n")
# list paths of files to download
filesD <- as.character(temp_meta$download_path)
# input for progress bar
total <- length(filesD)
pb <- utils::txtProgressBar(min = 0, max = total, style = 3)
# download files
lapply(X=filesD, function(x){
i <- match(c(x),filesD)
httr::GET(url=x, #httr::progress(),
httr::write_disk(paste0(tempdir(),"/", unlist(lapply(strsplit(x,"/"),tail,n=1L))), overwrite = T))
utils::setTxtProgressBar(pb, i)
}
)
# closing progress bar
close(pb)
# read files and pile them up
files <- unlist(lapply(strsplit(filesD,"/"), tail, n = 1L))
files <- paste0(tempdir(),"/",files)
files <- lapply(X=files, FUN= sf::st_read, quiet=T)
shape <- do.call('rbind', files)
return(shape)
}
shape
# list paths of files to download
if (is.numeric(code_micro)){ filesD <- as.character(subset(temp_meta, code==substr(code_micro, 1, 2))$download_path) }
if (is.character(code_micro)){ filesD <- as.character(subset(temp_meta, code_abrev==substr(code_micro, 1, 2))$download_path) }
# download files
temps <- download_gpkg()
# read sf
shape <- sf::st_read(temps, quiet=T)
shape
