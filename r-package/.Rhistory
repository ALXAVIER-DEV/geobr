temp
n
n
# dissolve borders to get neighborhoods
temp <- n %>%
group_by(zone, code_muni, name_muni, name_neighborhood,
code_neighborhood, code_subdistrict, name_subdistrict,
code_district, name_district, code_state) %>% summarize()
n <- subset(nei, name_muni =="GuajarÃ¡-Mirim")
n
# dissolve borders to get neighborhoods
temp <- n %>%
group_by(zone, code_muni, name_muni, name_neighborhood,
code_neighborhood, code_district, name_district, code_state) %>% summarize()
temp
plot(temp)
nei
n <- subset(nei, name_muni =="Alta Floresta D'oeste")
# dissolve borders to get neighborhoods
temp <- n %>%
group_by(zone, code_muni, name_muni, name_neighborhood,
code_neighborhood, code_district, name_district, code_state) %>% summarize()
temp
plot(temp)
n <- subset(nei, name_muni =="Rio de Janeiro")
# dissolve borders to get neighborhoods
temp <- n %>%
group_by(zone, code_muni, name_muni, name_neighborhood,
code_neighborhood, code_district, name_district, code_state) %>% summarize()
n <- subset(nei, name_muni =="Rio De Janeiro")
# dissolve borders to get neighborhoods
temp <- n %>%
group_by(zone, code_muni, name_muni, name_neighborhood,
code_neighborhood, code_district, name_district, code_state) %>% summarize()
plot(temp)
all_muni[1:4]
x <- lapply(X= all_muni[1:4], FUN = get_neibhd)
get_neibhd <- function(codemuni) {
# subset muni
n <- subset(nei, code_muni == codemuni)
# dissolve borders to get neighborhoods
temp <- n %>%
group_by(
zone,
code_muni,
name_muni,
name_neighborhood,
code_neighborhood,
code_district,
name_district,
code_state
) %>% summarize()
# return neighborhoods of muni
return(temp)
# setDT(n)
# a <- n[, .(geom = st_union(geom)), by= .(code_muni, code_neighborhood)]
# a <- st_as_sf(a)
# st_crs(a) <- 4674
#
# plot(a)
}
# get all municipalities
all_muni <- unique(nei$code_muni)
x <- lapply(X= all_muni[1:4], FUN = get_neibhd)
x <- lapply(X= all_muni[1:4], FUN = get_neibhd) %>% rbindlist()
x
class(x)
x <- lapply(X= all_muni[1:4], FUN = get_neibhd) %>% rbind_list()
x
head(x)
plot(x)
class(x)
x <- lapply(X= all_muni[1:4], FUN = get_neibhd) %>% rbind_all()
temp_list <- lapply(X= all_muni[1:4], FUN = get_neibhd)
temp_sf <- do.call('rbind', temp_list)
plot(temp_sf)
mapview(temp_sf)
a <- future.apply::future_lapply(X = all_muni[1:4], FUN=get_neibhd, future.packages=c('sf', 'dplyr'))
# in parellel
future::plan(future::multiprocess)
temp_list <- future.apply::future_lapply(X = all_muni[1:4], FUN=get_neibhd, future.packages=c('sf', 'dplyr'))
rm(temp_list)
library(pbapply)
rm(temp_list)
rm(temp_list)
temp_list <- future.apply::future_lapply(X = all_muni[1:14], FUN=get_neibhd, future.packages=c('sf', 'dplyr'))
# pile all cities up
temp_sf <- do.call('rbind', temp_list)
mapview(temp_sf)
lookup_muni('distrito federal')
lookup_muni('brasilial')
lookup_muni('brasilia')
library(covr)
library(testthat)
library(geobr)
Sys.setenv(NOT_CRAN = "true")
function_coverage(fun='download_metadata', test_file("tests/testthat/test-download_metadata.R"))
function_coverage(fun='list_geobr', test_file("tests/testthat/test-list_geobr.R"))
function_coverage(fun='lookup_muni', test_file("tests/testthat/test-lookup_muni.R"))
function_coverage(fun='grid_state_correspondence_table', test_file("tests/testthat/test-grid_state_correspondence_table.R"))
function_coverage(fun='read_biomes', test_file("tests/testthat/test-read_biomes.R"))
test_that("lookup_muni", {
# read data
test_sf <- lookup_muni(name_muni = "fortaleza")
test_sf2 <- lookup_muni(code_muni=2304400)
test_sf3 <- lookup_muni(name_muni="all")
test_sf4 <- lookup_muni(code_muni="all")
# check sf object
expect_true(is(test_sf, "data.frame"))
expect_true(is(test_sf2, "data.frame"))
expect_true(is(test_sf3, "data.frame"))
expect_true(is(test_sf4, "data.frame"))
# check number of cols
expect_equal( ncol(test_sf), 13)
# When using two arguments (supposed to give a warning)
expect_warning(lookup_muni(name_muni="fortaleza", code_muni=2304400))
expect_warning( lookup_muni(name_muni="arroz", code_muni=2304400) )
})
# ERRORS and messagens  -----------------------
test_that("lookup_muni", {
expect_error(lookup_muni())
expect_error(lookup_muni(name_muni="arroz", code_muni=123213))
# Wrong name
expect_error(lookup_muni(name_muni="arroz"))
# Wrong code
expect_error(lookup_muni(code_muni=99999999))
})
metadata <- download_metadata(geography = 'amazonia_legal')
testthat::expect_true(is(metadata, "data.frame"))
testthat::expect_equal(ncol(metadata), 5)
test_that("download_metadata", {
metadata <- download_metadata(geography = 'amazonia_legal')
testthat::expect_true(is(metadata, "data.frame"))
testthat::expect_equal(ncol(metadata), 5)
})
# Expected errors
test_that("download_metadata", {
testthat::expect_error( download_metadata( )  )
testthat::expect_error( download_metadata(data_type="asdasd") )
testthat::expect_error( download_metadata(geography = "aaa")  )
})
download_metadata( )
library(geobr)
library(covr)
library(testthat)
library(geobr)
Sys.setenv(NOT_CRAN = "true")
function_coverage(fun='download_metadata', test_file("tests/testthat/test-download_metadata.R"))
download_metadata( )
download_metadata(data_type="asdasd")
download_metadata(geography = "aaa")
testthat::expect_error( download_metadata(data_type= 2) )
function_coverage(fun='download_metadata', test_file("tests/testthat/test-download_metadata.R"))
function_coverage(fun='download_metadata', test_file("tests/testthat/test-download_metadata.R"))
httr::GET(url="http://www.ipea.gov.br/geobr/metadata/metadata_gpkgss.csv", httr::write_disk(tempf, overwrite = T))
utils::read.csv(tempf, stringsAsFactors=F)
#' @export
#' @family general support functions
#' @examples \donttest{
#'
#' library(geobr)
#'
#' df <- download_metadata()
#'
#' }
#'
download_metadata <- function(geography, data_type=TRUE){
# Get metadata with data addresses
tempf <- file.path(tempdir(), "metadata.csv")
# check if metadata has already been downloaded
if (file.exists(tempf)) {
metadata <- utils::read.csv(tempf, stringsAsFactors=F)
} else {
# download it and save to metadata
httr::GET(url="http://www.ipea.gov.br/geobr/metadata/metadata_gpkgs.csv", httr::write_disk(tempf, overwrite = T))
metadata <- utils::read.csv(tempf, stringsAsFactors=F)
}
# Select geo
if( is.null(geography) ){
stop(paste0("Error: Invalid Value to argument 'geography'. It must be one of the following: ",
paste(unique(metadata$geo), collapse = ", ")))
} else if( !(geography %in% metadata$geo)){
stop(paste0("Error: Invalid Value to argument 'geography'. It must be one of the following: ",
paste(unique(metadata$geo), collapse = ", ")))
} else { temp_meta <- subset(metadata, geo == geography) }
# Select data type
temp_meta <- select_data_type(temp_meta, simplified=data_type)
return(temp_meta)
}
download_metadata( )
download_metadata(geography = 'amazonia_legal')
#library(magrittr)
library(sf)
library(dplyr)
library(data.table)
library(geobr)
library(ggplot2)
library(mapview)
download_metadata(geography = 'amazonia_legal')
# Get metadata with data addresses
tempf <- file.path(tempdir(), "metadata.csv")
# check if metadata has already been downloaded
if (file.exists(tempf)) {
metadata <- utils::read.csv(tempf, stringsAsFactors=F)
} else {
# download it and save to metadata
httr::GET(url="http://www.ipea.gov.br/geobr/metadata/metadata_gpkgs.csv", httr::write_disk(tempf, overwrite = T))
metadata <- utils::read.csv(tempf, stringsAsFactors=F)
}
metadata
metadata
tempf
httr::GET(url="http://www.ipea.gov.br/geobr/metadata/metadata_gpkgs.csv", httr::write_disk(tempf, overwrite = T))
httr::GET(url="http://www.ipea.gov.br/geobr/metadata/metadata_gpkgssss.csv", httr::write_disk(tempf, overwrite = T))
httr::GET(url="http://www.ipea.gov.br/geobr/metadata/metadata_gpkgssss.csv", httr::write_disk(tempf, overwrite = T))
httr::GET(url="http://www.ipea.gov.br/geobr/metadata/metadata_gpkg.csv", httr::write_disk(tempf, overwrite = T))
metadata
metadata <- utils::read.csv(tempf, stringsAsFactors=F)
metadata
httr::GET(url="http://www.ipea.gov.br/geobr/metadata/metadata_gpksg.csv", httr::write_disk(tempf, overwrite = T))
metadata <- utils::read.csv(tempf, stringsAsFactors=F)
metadata
library(covr)
library(testthat)
library(geobr)
Sys.setenv(NOT_CRAN = "true")
function_coverage(fun='download_metadata', test_file("tests/testthat/test-download_metadata.R"))
metadata <- download_metadata(geography = 'amazonia_legal')
library(geobr)
library(covr)
library(testthat)
library(geobr)
Sys.setenv(NOT_CRAN = "true")
function_coverage(fun='download_metadata', test_file("tests/testthat/test-download_metadata.R"))
function_coverage(fun='list_geobr', test_file("tests/testthat/test-list_geobr.R"))
function_coverage(fun='lookup_muni', test_file("tests/testthat/test-lookup_muni.R"))
system.time(  geobr_cov <- covr::package_coverage() )
geobr_cov
beepr::beep()
# download metadata
metadata <- download_metadata()
library(geobr)
# download metadata
metadata <- download_metadata()
metadata
head(metadata)
geography='amazon'
# Select geo
temp_meta <- subset(metadata, geo == geography)
temp_meta
geography='biomes'
geography
# Select geo
temp_meta <- subset(metadata, geo == geography)
temp_meta
year=2012
# Select year input
temp_meta <- select_year_input(temp_meta, y=year)
year=2019
# Select year input
temp_meta <- select_year_input(temp_meta, y=year)
library(geobr)
a <- read_amazon(year=2012)
}
a <- read_amazon(year=2012)
temp_meta <- select_metadata(geography="amazonia_legal", year=year, simplified=simplified)
year=2012
simplified=TRUE
showProgress=TRUE
# Get metadata with data url addresses
temp_meta <- select_metadata(geography="amazonia_legal", year=year, simplified=simplified)
# download metadata
metadata <- download_metadata()
geography="amazonia_legal"
year=year
simplified=simplified
# download metadata
metadata <- download_metadata()
metadata
# Select geo
temp_meta <- subset(metadata, geo == geography)
temp_meta
# Select year input
temp_meta <- select_year_input(temp_meta, y=year)
temp_meta
temp_meta <- select_data_type(temp_meta, simplified=simplified)
temp_meta
temp_meta
library(geobr)
a <- read_amazon(year=2012)
#' @family general area functions
#' @examples \donttest{
#'
#' library(geobr)
#'
#' # Read biomes
#'   b <- read_biomes(year=2019)
#'
#'}
#'
read_biomes <- function(year=2019, simplified=TRUE, showProgress=TRUE){
# Get metadata with data url addresses
temp_meta <- select_metadata(geography="biomes", year=year, simplified=simplified)
# Test year input
temp_meta <- test_year_input(temp_meta, y=year)
# list paths of files to download
file_url <- as.character(temp_meta$download_path)
# download files
temp_sf <- download_gpkg(file_url, progress_bar = showProgress)
return(temp_sf)
}
#' @family general area functions
#' @examples \donttest{
#'
#' library(geobr)
#'
#' # Read biomes
#'   b <- read_biomes(year=2019)
#'
#'}
#'
read_biomes <- function(year=2019, simplified=TRUE, showProgress=TRUE){
# Get metadata with data url addresses
temp_meta <- select_metadata(geography="biomes", year=year, simplified=simplified)
# list paths of files to download
file_url <- as.character(temp_meta$download_path)
# download files
temp_sf <- download_gpkg(file_url, progress_bar = showProgress)
return(temp_sf)
}
b <- read_biomes(year=2019)
library(geobr)
library(covr)
library(testthat)
library(geobr)
Sys.setenv(NOT_CRAN = "true")
function_coverage(fun='read_biomes', test_file("tests/testthat/test-read_biomes.R"))
function_coverage(fun= 'read_amazon', test_file("tests/testthat/test-read_amazon.R"))
function_coverage(fun='read_census_tract', test_file("tests/testthat/test-read_census_tract.R"))
library(covr)
library(testthat)
library(geobr)
Sys.setenv(NOT_CRAN = "true")
function_coverage(fun='download_metadata', test_file("tests/testthat/test-download_metadata.R"))
test_that("download_metadata", {
metadata <- download_metadata(geography = 'amazonia_legal')
testthat::expect_true(is(metadata, "data.frame"))
testthat::expect_equal(ncol(metadata), 5)
})
metadata <- download_metadata()
testthat::expect_true(is(metadata, "data.frame"))
testthat::expect_equal(ncol(metadata), 5)
testthat::expect_error( download_metadata( )  )
testthat::expect_error( download_metadata(data_type="asdasd") )
testthat::expect_error( download_metadata(geography = "aaa")  )
testthat::expect_error( download_metadata("asdasd") )
testthat::expect_error( download_metadata( NULL)  )
testthat::expect_error( download_metadata("asdasd") )
testthat::expect_error( download_metadata( NULL)  )
function_coverage(fun='download_metadata', test_file("tests/testthat/test-download_metadata.R"))
testthat::expect_output( download_metadata() )
download_metadata(
)
function_coverage(fun='download_metadata', test_file("tests/testthat/test-download_metadata.R"))
function_coverage(fun='list_geobr', test_file("tests/testthat/test-list_geobr.R"))
function_coverage(fun='lookup_muni', test_file("tests/testthat/test-lookup_muni.R"))
function_coverage(fun='grid_state_correspondence_table', test_file("tests/testthat/test-grid_state_correspondence_table.R"))
temp_meta <- select_metadata(geography="lookup_muni", year=NULL, simplified=F)
temp_meta <- select_metadata(geography="lookup_muni", year=2010, simplified=F)
temp_meta
function_coverage(fun='lookup_muni', test_file("tests/testthat/test-lookup_muni.R"))
function_coverage(fun='lookup_muni', test_file("tests/testthat/test-lookup_muni.R"))
library(covr)
library(testthat)
library(geobr)
Sys.setenv(NOT_CRAN = "true")
function_coverage(fun='lookup_muni', test_file("tests/testthat/test-lookup_muni.R"))
function_coverage(fun='read_biomes', test_file("tests/testthat/test-read_biomes.R"))
function_coverage(fun='read_region', test_file("tests/testthat/test-read_region.R"))
function_coverage(fun= 'read_amazon', test_file("tests/testthat/test-read_amazon.R"))
function_coverage(fun= 'read_semiarid', test_file("tests/testthat/test-read_semiarid.R"))
function_coverage(fun= 'read_metro_area', test_file("tests/testthat/test-read_metro_area.R"))
function_coverage(fun= 'read_conservation_units', test_file("tests/testthat/test-read_conservation_units.R"))
test_that("read_conservation_units", {
# read data
test_sf <- read_conservation_units(date=201909)
testthat::expect_output(read_conservation_units())
# check sf object
testthat::expect_true(is(test_sf, "sf"))
# check projection
testthat::expect_equal(sf::st_crs(test_sf)[[2]], "+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs")
})
library(covr)
library(testthat)
library(geobr)
Sys.setenv(NOT_CRAN = "true")
function_coverage(fun= 'read_conservation_units', test_file("tests/testthat/test-read_conservation_units.R"))
function_coverage(fun='read_health_facilities', test_file("tests/testthat/test-read_health_facilities.R"))
# Get metadata with data url addresses
temp_meta <- select_metadata(geography="health_facilities", year=NULL, simplified=F)
# Get metadata with data url addresses
temp_meta <- select_metadata(geography="health_facilities", year=2015, simplified=F)
# list paths of files to download
file_url <- as.character(temp_meta$download_path)
file_url
function_coverage(fun='read_intermediate_region', test_file("tests/testthat/test-read_intermediate_region.R"))
function_coverage(fun='read_immediate_region', test_file("tests/testthat/test-read_immediate_region.R"))
function_coverage(fun='read_municipality', test_file("tests/testthat/test-read_municipality.R"))
function_coverage(fun='read_census_tract', test_file("tests/testthat/test-read_census_tract.R"))
function_coverage(fun='read_weighting_area', test_file("tests/testthat/test-read_weighting_area.R"))
# update Package coverage
Sys.setenv(NOT_CRAN = "true")
system.time(  geobr_cov <- covr::package_coverage() )
# update Package coverage
Sys.setenv(NOT_CRAN = "true")
system.time(  geobr_cov <- covr::package_coverage() )
geobr_cov
beepr::beep()
geobr_cov
grid_state_correspondence_table
function_coverage(fun='grid_state_correspondence_table', test_file("tests/testthat/test-grid_state_correspondence_table.R"))
data(grid_state_correspondence_table)
head(grid_state_correspondence_table)
expect_equal(ncol(grid_state_correspondence_table), 3)
expect_equal(nrow(grid_state_correspondence_table), 139)
test_that("grid_state_correspondence_table", {
# load data
#  load( system.file("data/grid_state_correspondence_table.RData", package="geobr") )
data(grid_state_correspondence_table)
head(grid_state_correspondence_table)
# test
expect_equal(ncol(grid_state_correspondence_table), 3)
expect_equal(nrow(grid_state_correspondence_table), 139)
})
context("grid_state_correspondence_table")
# skip tests because they take too much time
testthat::skip_on_cran()
test_that("grid_state_correspondence_table", {
# load data
#  load( system.file("data/grid_state_correspondence_table.RData", package="geobr") )
data(grid_state_correspondence_table)
head(grid_state_correspondence_table)
# test
expect_equal(ncol(grid_state_correspondence_table), 3)
expect_equal(nrow(grid_state_correspondence_table), 139)
})
function_coverage(fun='grid_state_correspondence_table', test_file("tests/testthat/test-grid_state_correspondence_table.R"))
Sys.setenv(NOT_CRAN = "false")
function_coverage(fun='read_urban_area', test_file("tests/testthat/test-read_urban_area.R"))
# Check package errors
Sys.setenv(NOT_CRAN = "false")
# Check package errors
Sys.setenv(NOT_CRAN = "false")
devtools::check(pkg = ".",  cran = TRUE)
library(geobr)
read_state()
testthat::expect_output( read_state() )
read_state(code_state=9999999, year=9999999)
expect_error(read_state(code_state=9999999, year=9999999))
# Wrong year and code
testthat::expect_error(read_state(code_state=9999999, year=9999999))
context("read_state")
# skip tests because they take too much time
testthat::skip_on_cran()
test_that("read_state", {
# read data
testthat::expect_output( read_state() )
testthat::expect_output( read_state(code_state=11, year=1991) )
testthat::expect_output( read_state(code_state="AC", year=2010) )
testthat::expect_output( read_state(code_state=11, year=2010) )
testthat::expect_output( read_state(code_state="all") )
test_code <- read_state(code_state=11, year=2010)
# check sf object
expect_true(is(test_code, "sf"))
# check number of weighting areas
expect_equal(nrow(test_code), 1)
# check projection
expect_equal(sf::st_crs(test_code)[[2]], "+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs")
})
library(testthat)
test_that("read_state", {
# read data
testthat::expect_output( read_state() )
testthat::expect_output( read_state(code_state=11, year=1991) )
testthat::expect_output( read_state(code_state="AC", year=2010) )
testthat::expect_output( read_state(code_state=11, year=2010) )
testthat::expect_output( read_state(code_state="all") )
test_code <- read_state(code_state=11, year=2010)
# check sf object
testthat::expect_true(is(test_code, "sf"))
# check number of weighting areas
testthat::expect_equal(nrow(test_code), 1)
# check projection
testthat::expect_equal(sf::st_crs(test_code)[[2]], "+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs")
})
# ERRORS
test_that("read_state", {
# Wrong year and code
testthat::expect_error(read_state(code_state=9999999, year=9999999))
# Wrong code
testthat::expect_error( read_state(code_state=NULL, year=1991) ) # EXception
testthat::expect_error(read_state(code_state=9999999))
testthat::expect_error(read_state(code_state=5201108312313213123123123))
testthat::expect_error(read_state(code_state="AC_ABCD"))
# Wrong year
testthat::expect_error(read_state( year=9999999))
})
library(covr)
library(testthat)
library(geobr)
Sys.setenv(NOT_CRAN = "true")
function_coverage(fun='read_state', test_file("tests/testthat/test-read_state.R"))
